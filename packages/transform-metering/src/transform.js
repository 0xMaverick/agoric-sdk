import * as c from './constants';

const METER_GENERATED = Symbol('meter-generated');

export function makeMeteringTransformer(
  babelCore,
  overrideParser = undefined,
  overrideMeterId = c.DEFAULT_METER_ID,
) {
  const parser = overrideParser
    ? overrideParser.parse || overrideParser
    : babelCore.parseSync;
  const meterId = overrideMeterId;

  const meteringPlugin = ({ types: t }) => {
    // Call [[meterId]][idString](...args)
    const meterCall = (idString, args = []) => {
      const mid = t.Identifier(meterId);
      mid[METER_GENERATED] = true;
      return t.CallExpression(
        t.MemberExpression(mid, t.Identifier(idString)),
        args,
      );
    };

    // Wrap expr with `{ return expr; }` if necessary.
    const blockify = (exprOrBlock, doReturn = false) => {
      switch (exprOrBlock.type) {
        case 'BlockStatement': {
          const { body, directives } = exprOrBlock;
          return t.blockStatement([...body], directives);
        }
        case 'EmptyStatement':
          return t.BlockStatement([]);
        default:
          if (!doReturn) {
            return t.BlockStatement([exprOrBlock]);
          }
          if (exprOrBlock.type === 'ExpressionStatement') {
            return t.BlockStatement([
              t.ReturnStatement(exprOrBlock.expression),
            ]);
          }
          return t.BlockStatement([t.ReturnStatement(exprOrBlock)]);
      }
    };

    // Transform a body into a stack-metered try...finally block.
    const wrapWithStackMeter = tryBlock => {
      tryBlock.body.unshift(t.ExpressionStatement(meterCall(c.METER_ENTER)));
      const finalizer = t.BlockStatement([
        t.ExpressionStatement(meterCall(c.METER_LEAVE)),
      ]);
      finalizer[METER_GENERATED] = true;
      const tryStatement = t.BlockStatement([
        t.TryStatement(tryBlock, null, finalizer),
      ]);
      return tryStatement;
    };

    // Transform a body into a compute-metered block.
    const wrapWithComputeMeter = block => {
      block.body.unshift(t.ExpressionStatement(meterCall(c.METER_COMPUTE)));
      return block;
    };

    const visitor = {
      // Ensure meter identifiers are generated by us, or abort.
      Identifier(path) {
        if (path.node.name === meterId && !path.node[METER_GENERATED]) {
          throw path.buildCodeFrameError(
            `Identifier ${path.node.name} is reserved for metering code`,
          );
        }
      },
      // Loop constructs need only a compute meter.
      DoWhileStatement(path) {
        path.node.body = wrapWithComputeMeter(blockify(path.node.body));
      },
      ForStatement(path) {
        path.node.body = wrapWithComputeMeter(blockify(path.node.body));
      },
      ForOfStatement(path) {
        path.node.body = wrapWithComputeMeter(blockify(path.node.body));
      },
      ForInStatement(path) {
        path.node.body = wrapWithComputeMeter(blockify(path.node.body));
      },
      WhileStatement(path) {
        path.node.body = wrapWithComputeMeter(blockify(path.node.body));
      },
      // To prevent interception after exhaustion, wrap catch and finally.
      TryStatement(path) {
        if (path.node.handler) {
          path.node.handler = wrapWithComputeMeter(path.node.handler);
        }
        if (path.node.finalizer && !path.node.finalizer[METER_GENERATED]) {
          path.node.finalizer = wrapWithComputeMeter(path.node.finalizer);
        }
      },
      // Function definitions need a stack meter, too.
      ArrowFunctionExpression(path) {
        path.node.body = wrapWithStackMeter(blockify(path.node.body, true));
      },
      ClassMethod(path) {
        path.node.body = wrapWithStackMeter(path.node.body);
      },
      FunctionExpression(path) {
        path.node.body = wrapWithStackMeter(path.node.body);
      },
      FunctionDeclaration(path) {
        path.node.body = wrapWithStackMeter(path.node.body);
      },
      ObjectMethod(path) {
        path.node.body = wrapWithStackMeter(path.node.body);
      },
    };
    return { visitor };
  };

  const meteringTransform = {
    rewrite(ss) {
      const { source, endowments } = ss;

      // Do the actual transform.
      const ast = parser(source);
      const output = babelCore.transformFromAstSync(ast, source, {
        generatorOpts: {
          retainLines: true,
        },
        plugins: [meteringPlugin],
        ast: true,
        code: true,
      });

      // Meter by the source length.
      const meterSource = `\
${meterId}.${c.METER_COMPUTE}(${output.code.length});`;

      // Force into an IIFE, if necessary.
      const maybeSource = output.code;
      const actualSource =
        ss.sourceType === 'expression'
          ? `(function(){${meterSource}return ${maybeSource}})()`
          : `${meterSource}${maybeSource}`;

      return {
        ...ss,
        ast,
        endowments,
        source: actualSource,
      };
    },
  };

  return { meterId, meteringTransform };
}
