import {ask, SETUP_DIR, SSH_TYPE} from './setup';
import {basename, createFile, mkdir, needNotExists, resolve} from './files';
import {needDoRun} from './run';
import fetch from 'node-fetch';

const ALL_PROVIDERS = ['digitalocean'];

const doInit = async (progname, args) => {
    let [dir, NETWORK_NAME] = args.slice(1);
    if (!dir) {
      dir = CHAIN_HOME;
    }
    if (!dir) {
      throw `Need: [dir] [[network name]]`;
    }
    await needNotExists(`${dir}/ansible.cfg`);
  
    let subs = '', subSep = '';
    const doSub = (vname, value) => {
      subs += `${subSep}s!@${vname}@!${value}!g`;
      subSep = '; ';
    };
  
    const adir = resolve(process.cwd(), dir);
    const SSH_PRIVATE_KEY_FILE = resolve(adir, `id_${SSH_TYPE}`);
    const BACKEND_TF = process.env.AG_SETUP_COSMOS_BACKEND;
    if (!NETWORK_NAME) {
      NETWORK_NAME = basename(dir);
    }
    doSub('PWD', adir);
    doSub('SETUP_DIR', SETUP_DIR);
    doSub('NETWORK_NAME', NETWORK_NAME);
    doSub('SSH_KEY_FILE', `${SSH_PRIVATE_KEY_FILE}.pub`);
  
    // TODO: Gather information and persist so they can change it before commit.
    let instance = 0;
    const OFFSETS = {};
    const API_KEYS = {};
    const DATACENTERS = {};
    try {
      await mkdir(dir);
    } catch (e) {}
    for (const provider of ALL_PROVIDERS.sort()) {
      let enable = await ask(`Do you want to use ${provider} (Y/n)? `);
      if (enable.trim().match(/^n/i)) {
          continue;
      }

      let defApiKey;
      switch (provider) {
          case 'digitalocean':
              defApiKey = process.env.DO_API_TOKEN;
              break;
      }

      let apikey = await ask(`What is your ${provider} API Key? `, defApiKey);
      apikey.trim();
      if (!apikey) {
        console.error(`No API Keys configured for ${provider}; skipping...`)
        continue;
      }

      let dcCompletions;
      switch (provider) {
          case 'digitalocean': {
            const res = await fetch('https://api.digitalocean.com/v2/regions', {
                headers: {'Authorization': `Bearer ${apikey}`},
            });
            const json = await res.json();
            dcCompletions = json.regions.map(r => r.slug.toUpperCase()).sort();
            break;
          }
      }
  
      const offset = instance;
      const dcs = [];
      while (true) {
        const dflt = (dcCompletions && offset === instance) ? dcCompletions[0] : 'next provider';
        let dc = await ask(`node${instance} ${provider} datacenter? `, dflt,
          dcCompletions);
        dc = dc.trim();
        if (dc === 'next provider') {
          break;
        }
        if (dcCompletions && !dcCompletions.includes(dc)) {
            console.error(`Datacenter must be one of: ${dcCompletions.join(' ')}`);
            continue;
        }
        instance ++;
        dcs.push(dc);
      }
  
      if (dcs.length === 0) {
        console.error(`No nodes configured for ${provider}; skipping...`)
        continue;
      }
  
      API_KEYS[provider] = apikey;
      OFFSETS[provider] = offset;
      DATACENTERS[provider] = dcs;
    }
      
    if (instance === 0) {
      throw `Aborting due to no nodes configured!`;
    }
  
    await createFile(`${dir}/vars.tf`, `\
# Terraform configuration generated by "${progname} init"
  
variable "NETWORK_NAME" {
  default = "${NETWORK_NAME}"
}
  
variable "SSH_KEY_FILE" {
  default = "${SSH_PRIVATE_KEY_FILE}.pub"
}
  
variable "DATACENTERS" {
  default = {
${Object.keys(DATACENTERS).sort().map(p => `    ${p} = ${JSON.stringify(DATACENTERS[p])}`).join('\n')}
  }
}
  
variable "OFFSETS" {
  default = {
${Object.keys(OFFSETS).sort().map(p => `     ${p} = ${OFFSETS[p]}`).join('\n')}
  }
}
  
variable "API_KEYS" {
  default = {
${Object.keys(API_KEYS).sort().map(p => `    ${p} = ${JSON.stringify(API_KEYS[p])}`).join('\n')}
  }
}
`);
  
    const clusterPrefix = 'ag-chain-cosmos-';
    for (const p of Object.keys(DATACENTERS).sort()) {
      switch (p) {
        case 'digitalocean': {
          await createFile(`${dir}/${p}.tf`, `\
module "${p}" {
  source           = "${SETUP_DIR}/terraform/${p}"
  CLUSTER_NAME     = "${clusterPrefix}\${var.NETWORK_NAME}-${p}"
  OFFSET           = "\${var.OFFSETS["${p}"]}"
  REGIONS          = "\${var.DATACENTERS["${p}"]}"
  SSH_KEY_FILE     = "\${var.SSH_KEY_FILE}"
  DO_API_TOKEN     = "\${var.API_KEYS["${p}"]}"
  SERVERS          = "\${length(var.DATACENTERS["${p}"])}"
}
`);
          break;
        }
        default:
          throw `Do not know how to write provider ${p}.tf`;
      }
    }
  
    await createFile(`${dir}/outputs.tf`, `\
output "public_ips" {
  value = {
${Object.keys(DATACENTERS).sort().map(p => `    ${p} = "\${module.${p}.public_ips}"`).join('\n')}
  }
}
  
output "offsets" {
  value = "\${var.OFFSETS}"
}
  `);
  
    // TODO: Do this all within Node so it works on Windows.
    if (BACKEND_TF) {
      await needDoRun(['sh', '-c',
        `sed -e 's!@WORKSPACE_NAME@!ag-chain-cosmos-${NETWORK_NAME}!g' ${shellEscape(BACKEND_TF)} > ${shellEscape(`${dir}/backend.tf`)}`]);
    }
    // Set empty password.
    await needDoRun(['ssh-keygen', '-N', '', '-t', SSH_TYPE, '-f', SSH_PRIVATE_KEY_FILE])
  
    // Finish by writing ansible.cfg.
    await createFile(`${dir}/ansible.cfg`, `\
[defaults]
inventory = ./hosts
  
[ssh_connection]
ssh_args = -oForwardAgent=yes -oUserKnownHostsFile=ssh_known_hosts -oControlMaster=auto -oControlPersist=30m
`);
};

export default doInit;
